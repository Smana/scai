package terraform

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/Smana/scia/internal/types"
)

// Generator handles Terraform configuration generation
type Generator struct {
	outputDir string
	verbose   bool
}

// NewGenerator creates a new Terraform generator
func NewGenerator(outputDir string, verbose bool) *Generator {
	return &Generator{
		outputDir: outputDir,
		verbose:   verbose,
	}
}

// Generate creates Terraform configuration based on the strategy
func (g *Generator) Generate(config *types.TerraformConfig) error {
	// Create output directory
	if err := os.MkdirAll(g.outputDir, 0o755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Copy OpenTofu modules to work directory
	if err := g.copyModules(); err != nil {
		return fmt.Errorf("failed to copy modules: %w", err)
	}

	// Generate strategy-specific configuration
	switch config.Strategy {
	case "vm":
		return g.generateEC2Config(config)
	case "kubernetes":
		return g.generateEKSConfig(config)
	case "serverless":
		return g.generateLambdaConfig(config)
	default:
		return fmt.Errorf("unknown deployment strategy: %s", config.Strategy)
	}
}

// copyModules copies OpenTofu modules to the work directory
func (g *Generator) copyModules() error {
	// For now, use inline module source instead of copying
	// The modules will be referenced from the project directory
	return nil
}

// generateEC2Config generates EC2 configuration using terraform-aws-modules/autoscaling
func (g *Generator) generateEC2Config(config *types.TerraformConfig) error {
	// Generate user-data script
	userData := g.generateUserData(config)

	mainTF := fmt.Sprintf(`# EC2 Deployment for %s using terraform-aws-modules/autoscaling
# Generated by SCIA

terraform {
  required_version = ">= 1.0"
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = "%s"
}

# Get latest Amazon Linux 2023 AMI
data "aws_ami" "amazon_linux_2023" {
  most_recent = true
  owners      = ["amazon"]

  filter {
    name   = "name"
    values = ["al2023-ami-*-x86_64"]
  }

  filter {
    name   = "virtualization-type"
    values = ["hvm"]
  }
}

# Get default VPC
data "aws_vpc" "default" {
  default = true
}

# Get default subnets
data "aws_subnets" "default" {
  filter {
    name   = "vpc-id"
    values = [data.aws_vpc.default.id]
  }
}

# Security Group Module
module "security_group" {
  source  = "terraform-aws-modules/security-group/aws"
  version = "5.3.0"

  name        = "%s-sg"
  description = "Security group for %s"
  vpc_id      = data.aws_vpc.default.id

  ingress_with_cidr_blocks = [
    {
      from_port   = %d
      to_port     = %d
      protocol    = "tcp"
      cidr_blocks = "0.0.0.0/0"
      description = "Application port"
    },
    {
      from_port   = 22
      to_port     = 22
      protocol    = "tcp"
      cidr_blocks = "0.0.0.0/0"
      description = "SSH access"
    }
  ]

  egress_with_cidr_blocks = [
    {
      from_port   = 0
      to_port     = 0
      protocol    = "-1"
      cidr_blocks = "0.0.0.0/0"
      description = "Allow all outbound"
    }
  ]

  tags = {
    Name = "%s-sg"
  }
}

# Auto Scaling Group Module - Single instance with auto-recovery
module "asg" {
  source  = "terraform-aws-modules/autoscaling/aws"
  version = "~> 8.0"

  name = "%s-asg"

  # Single instance configuration for auto-recovery
  min_size         = 1
  max_size         = 1
  desired_capacity = 1

  vpc_zone_identifier = data.aws_subnets.default.ids

  # Health check configuration
  health_check_type         = "EC2"
  health_check_grace_period = 300

  # Launch template configuration
  image_id          = data.aws_ami.amazon_linux_2023.id
  instance_type     = "%s"

  security_groups = [module.security_group.security_group_id]

  # Root volume configuration
  block_device_mappings = [
    {
      device_name = "/dev/xvda"
      ebs = {
        volume_size           = %d
        volume_type           = "gp3"
        delete_on_termination = true
        encrypted             = true
      }
    }
  ]

  user_data = base64encode(<<-EOF
%s
  EOF
  )

  # Enable detailed monitoring
  enable_monitoring = true

  # Instance metadata options
  metadata_options = {
    http_endpoint               = "enabled"
    http_tokens                 = "required"
    http_put_response_hop_limit = 1
  }

  tags = {
    Name        = "%s"
    Environment = "production"
    ManagedBy   = "SCIA"
  }
}

output "asg_name" {
  description = "Auto Scaling Group name"
  value       = module.asg.autoscaling_group_name
}

output "security_group_id" {
  description = "Security Group ID"
  value       = module.security_group.security_group_id
}

output "application_url" {
  description = "Application URL (note: may take a few minutes for instance to be ready)"
  value       = "App will be available on port %d after instance launches"
}
`,
		config.AppName,           // Line 1: Comment
		config.Region,            // provider region
		config.AppName,           // SG name
		config.AppName,           // SG description
		config.Port, config.Port, // ingress ports
		config.AppName,      // SG tag
		config.AppName,      // ASG name
		config.InstanceType, // instance type
		config.VolumeSize,   // volume size
		userData,            // user-data script
		config.AppName,      // instance tag
		config.Port,         // application URL port
	)

	return os.WriteFile(filepath.Join(g.outputDir, "main.tf"), []byte(mainTF), 0o644)
}

// generateUserData creates the user-data script for EC2 instances
func (g *Generator) generateUserData(config *types.TerraformConfig) string {
	return fmt.Sprintf(`#!/bin/bash
set -e

# Log everything
exec > >(tee /var/log/user-data.log)
exec 2>&1

echo "Starting deployment for %s"
echo "Framework: %s, Language: %s"

# Install git
yum install -y git

# Clone repository
cd /home/ec2-user
git clone %s app || echo "Clone failed, continuing..."
cd app || exit 1

# Install dependencies based on language
case "%s" in
  python|Python)
    yum install -y python3 python3-pip
    pip3 install -r requirements.txt || echo "No requirements.txt"
    ;;
  javascript|node*)
    curl -fsSL https://rpm.nodesource.com/setup_18.x | bash -
    yum install -y nodejs
    npm install || echo "No package.json"
    ;;
  go|Go)
    yum install -y golang
    go mod download || echo "No go.mod"
    ;;
esac

echo "Setup complete. App ready at port %d"

# Start application (in production, use systemd service)
# %s
`,
		config.AppName,
		config.Framework, config.Language,
		config.RepoURL,
		config.Language,
		config.Port,
		config.StartCommand,
	)
}

// generateEKSConfig generates EKS configuration using terraform-aws-modules/eks
func (g *Generator) generateEKSConfig(config *types.TerraformConfig) error {
	// Determine container image based on language
	containerImage := g.detectContainerImage(config.Language, config.Framework)

	// Sanitize app name for Kubernetes (replace underscores with hyphens)
	k8sAppName := strings.ReplaceAll(config.AppName, "_", "-")

	mainTF := fmt.Sprintf(`# EKS Deployment for %s using terraform-aws-modules/eks
# Generated by SCIA

terraform {
  required_version = ">= 1.0"
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = "~> 2.20"
    }
  }
}

provider "aws" {
  region = "%s"
}

# Get available AZs
data "aws_availability_zones" "available" {
  state = "available"
}

# VPC Module
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "~> 6.0"

  name = "%s-vpc"
  cidr = "10.0.0.0/16"

  azs             = slice(data.aws_availability_zones.available.names, 0, 2)
  private_subnets = ["10.0.1.0/24", "10.0.2.0/24"]
  public_subnets  = ["10.0.101.0/24", "10.0.102.0/24"]

  enable_nat_gateway   = true
  single_nat_gateway   = true
  enable_dns_hostnames = true
  enable_dns_support   = true

  # EKS requires specific tags on subnets
  public_subnet_tags = {
    "kubernetes.io/role/elb" = "1"
  }

  private_subnet_tags = {
    "kubernetes.io/role/internal-elb" = "1"
  }

  tags = {
    Name        = "%s-vpc"
    Environment = "production"
    ManagedBy   = "SCIA"
  }
}

# EKS Module
module "eks" {
  source  = "terraform-aws-modules/eks/aws"
  version = "~> 21.0"

  cluster_name    = "%s-eks"
  cluster_version = "1.31"

  # Cluster endpoint access
  cluster_endpoint_public_access = true

  # Enable cluster creator admin permissions
  enable_cluster_creator_admin_permissions = true

  # VPC and subnet configuration
  vpc_id                   = module.vpc.vpc_id
  subnet_ids               = module.vpc.private_subnets
  control_plane_subnet_ids = module.vpc.private_subnets

  # EKS Managed Node Group
  eks_managed_node_groups = {
    default = {
      name = "%s-node-group"

      instance_types = ["%s"]
      capacity_type  = "ON_DEMAND"

      min_size     = %d
      max_size     = %d
      desired_size = %d

      block_device_mappings = {
        xvda = {
          device_name = "/dev/xvda"
          ebs = {
            volume_size           = %d
            volume_type           = "gp3"
            delete_on_termination = true
            encrypted             = true
          }
        }
      }

      tags = {
        Name        = "%s-node"
        Environment = "production"
        ManagedBy   = "SCIA"
      }
    }
  }

  tags = {
    Name        = "%s-eks"
    Environment = "production"
    ManagedBy   = "SCIA"
  }
}

# Configure Kubernetes provider
provider "kubernetes" {
  host                   = module.eks.cluster_endpoint
  cluster_ca_certificate = base64decode(module.eks.cluster_certificate_authority_data)

  exec {
    api_version = "client.authentication.k8s.io/v1beta1"
    command     = "aws"
    args = ["eks", "get-token", "--cluster-name", module.eks.cluster_name, "--region", "%s"]
  }
}

# Kubernetes Deployment
resource "kubernetes_deployment" "app" {
  depends_on = [module.eks]

  metadata {
    name = "%s-deployment"
    labels = {
      app = "%s"
    }
  }

  spec {
    replicas = 2

    selector {
      match_labels = {
        app = "%s"
      }
    }

    template {
      metadata {
        labels = {
          app = "%s"
        }
      }

      spec {
        container {
          name  = "%s"
          image = "%s"

          port {
            container_port = %d
          }

          env {
            name  = "APP_NAME"
            value = "%s"
          }

          env {
            name  = "REGION"
            value = "%s"
          }

          resources {
            requests = {
              cpu    = "100m"
              memory = "128Mi"
            }
            limits = {
              cpu    = "500m"
              memory = "512Mi"
            }
          }
        }
      }
    }
  }
}

# Kubernetes Service (LoadBalancer)
resource "kubernetes_service" "app" {
  depends_on = [kubernetes_deployment.app]

  metadata {
    name = "%s-service"
    labels = {
      app = "%s"
    }
  }

  spec {
    type = "LoadBalancer"

    selector = {
      app = "%s"
    }

    port {
      port        = 80
      target_port = %d
      protocol    = "TCP"
    }
  }
}

# Outputs
output "cluster_name" {
  description = "EKS cluster name"
  value       = module.eks.cluster_name
}

output "cluster_endpoint" {
  description = "EKS cluster endpoint"
  value       = module.eks.cluster_endpoint
}

output "cluster_security_group_id" {
  description = "Security group ID attached to the EKS cluster"
  value       = module.eks.cluster_security_group_id
}

output "vpc_id" {
  description = "VPC ID"
  value       = module.vpc.vpc_id
}

output "service_url" {
  description = "Application service URL (LoadBalancer hostname)"
  value       = kubernetes_service.app.status.0.load_balancer.0.ingress.0.hostname
}

output "kubeconfig_command" {
  description = "Command to configure kubectl"
  value       = "aws eks update-kubeconfig --region %s --name ${module.eks.cluster_name}"
}
`,
		config.AppName,           // Comment
		config.Region,            // provider region
		k8sAppName,               // VPC name
		k8sAppName,               // VPC tags
		k8sAppName,               // cluster name
		k8sAppName,               // node group name
		config.EKSNodeType,       // instance type
		config.EKSMinNodes,       // min size
		config.EKSMaxNodes,       // max size
		config.EKSDesiredNodes,   // desired size
		config.EKSNodeVolumeSize, // volume size
		k8sAppName,               // node tags
		k8sAppName,               // eks tags
		config.Region,            // kubectl region
		k8sAppName,               // deployment name
		k8sAppName,               // deployment label
		k8sAppName,               // selector label
		k8sAppName,               // template label
		k8sAppName,               // container name
		containerImage,           // container image
		config.Port,              // container port
		config.AppName,           // env APP_NAME (keep original for env var)
		config.Region,            // env REGION
		k8sAppName,               // service name
		k8sAppName,               // service label
		k8sAppName,               // service selector
		config.Port,              // target port
		config.Region,            // kubeconfig command region
	)

	return os.WriteFile(filepath.Join(g.outputDir, "main.tf"), []byte(mainTF), 0o644)
}

// generateLambdaConfig generates Lambda configuration using terraform-aws-modules/lambda
func (g *Generator) generateLambdaConfig(config *types.TerraformConfig) error {
	// Determine runtime
	runtime := g.detectRuntime(config.Language, config.Framework)
	handler := g.detectHandler(config.Framework)

	// Build reserved concurrency configuration if specified
	reservedConcurrency := ""
	if config.LambdaReservedConcurrency > 0 {
		reservedConcurrency = fmt.Sprintf("\n  reserved_concurrent_executions = %d", config.LambdaReservedConcurrency)
	}

	mainTF := fmt.Sprintf(`# Lambda Deployment for %s using terraform-aws-modules/lambda
# Generated by SCIA

terraform {
  required_version = ">= 1.0"
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = "%s"
}

# Lambda Function Module
module "lambda_function" {
  source  = "terraform-aws-modules/lambda/aws"
  version = "~> 8.0"

  function_name = "%s"
  description   = "Lambda function for %s deployed by SCIA"
  handler       = "%s"
  runtime       = "%s"

  # Package configuration - using Docker for build
  create_package      = false
  local_existing_package = "${path.module}/lambda.zip"

  # Function configuration
  timeout     = %d
  memory_size = %d%s

  # Environment variables
  environment_variables = {
    APP_NAME = "%s"
    REGION   = "%s"
  }

  # CloudWatch Logs
  cloudwatch_logs_retention_in_days = 7

  # Enable X-Ray tracing
  tracing_mode = "Active"

  tags = {
    Name        = "%s"
    Environment = "production"
    ManagedBy   = "SCIA"
  }
}

# API Gateway HTTP API
module "api_gateway" {
  source  = "terraform-aws-modules/apigateway-v2/aws"
  version = "5.4.0"

  name          = "%s-api"
  description   = "HTTP API Gateway for %s"
  protocol_type = "HTTP"

  # Disable custom domain features
  create_domain_name    = false
  create_certificate    = false
  create_domain_records = false

  # CORS configuration
  cors_configuration = {
    allow_headers = ["*"]
    allow_methods = ["*"]
    allow_origins = ["*"]
  }

  # Routes
  routes = {
    "ANY /{proxy+}" = {
      integration = {
        uri                    = module.lambda_function.lambda_function_arn
        payload_format_version = "2.0"
        timeout_milliseconds   = 30000
      }
    }

    "ANY /" = {
      integration = {
        uri                    = module.lambda_function.lambda_function_arn
        payload_format_version = "2.0"
        timeout_milliseconds   = 30000
      }
    }
  }

  tags = {
    Name        = "%s-api"
    ManagedBy   = "SCIA"
  }
}

# Lambda permission for API Gateway
resource "aws_lambda_permission" "api_gw" {
  statement_id  = "AllowExecutionFromAPIGateway"
  action        = "lambda:InvokeFunction"
  function_name = module.lambda_function.lambda_function_name
  principal     = "apigateway.amazonaws.com"
  source_arn    = "${module.api_gateway.api_execution_arn}/*/*"
}

# Null resource to prepare Lambda package
resource "null_resource" "lambda_package" {
  provisioner "local-exec" {
    command = <<-EOT
      echo "Preparing Lambda package..."
      mkdir -p lambda_build

      # Clone repository
      cd lambda_build
      git clone %s app || exit 1
      cd app

      # Install dependencies based on language
      case "%s" in
        python|Python)
          pip3 install -r requirements.txt -t . 2>/dev/null || echo "No requirements"
          ;;
        javascript|node*)
          npm install 2>/dev/null || echo "No package.json"
          ;;
      esac

      # Create deployment package
      zip -r ../../lambda.zip . -x "*.git*" "*.pyc" "__pycache__/*"

      echo "Lambda package created: lambda.zip"
    EOT
  }

  triggers = {
    always_run = timestamp()
  }
}

output "function_name" {
  description = "Lambda function name"
  value       = module.lambda_function.lambda_function_name
}

output "function_arn" {
  description = "Lambda function ARN"
  value       = module.lambda_function.lambda_function_arn
}

output "api_endpoint" {
  description = "API Gateway endpoint URL"
  value       = module.api_gateway.api_endpoint
}

output "api_invoke_url" {
  description = "API Gateway invoke URL"
  value       = "${module.api_gateway.api_endpoint}/"
}
`,
		config.AppName,       // Comment
		config.Region,        // provider region
		config.AppName,       // function_name
		config.AppName,       // description
		handler,              // handler
		runtime,              // runtime
		config.LambdaTimeout, // timeout
		config.LambdaMemory,  // memory_size
		reservedConcurrency,  // reserved_concurrent_executions (optional)
		config.AppName,       // env var APP_NAME
		config.Region,        // env var REGION
		config.AppName,       // tags Name
		config.AppName,       // API GW name
		config.AppName,       // API GW description
		config.AppName,       // API GW tags
		config.RepoURL,       // git clone
		config.Language,      // case statement
	)

	return os.WriteFile(filepath.Join(g.outputDir, "main.tf"), []byte(mainTF), 0o644)
}

// detectRuntime determines the Lambda runtime from language and framework
func (g *Generator) detectRuntime(language, framework string) string {
	switch language {
	case "python":
		return "python3.12"
	case "javascript", "typescript":
		return "nodejs20.x"
	case "go":
		return "provided.al2023"
	default:
		return "python3.12" // Default fallback
	}
}

// detectHandler determines the Lambda handler from framework
func (g *Generator) detectHandler(framework string) string {
	switch framework {
	case "flask":
		return "app.handler"
	case "django":
		return "wsgi.handler"
	case "fastapi":
		return "main.handler"
	case "express":
		return "index.handler"
	default:
		return "app.handler"
	}
}

// detectContainerImage determines the container image for EKS deployment
func (g *Generator) detectContainerImage(language, framework string) string {
	switch language {
	case "python":
		if framework == "flask" {
			return "python:3.12-slim"
		} else if framework == "django" {
			return "python:3.12-slim"
		} else if framework == "fastapi" {
			return "python:3.12-slim"
		}
		return "python:3.12-slim"
	case "javascript", "typescript":
		if framework == "express" {
			return "node:20-alpine"
		} else if framework == "nextjs" || framework == "next.js" {
			return "node:20-alpine"
		}
		return "node:20-alpine"
	case "go":
		return "golang:1.23-alpine"
	default:
		// Generic fallback
		return "nginx:alpine"
	}
}
